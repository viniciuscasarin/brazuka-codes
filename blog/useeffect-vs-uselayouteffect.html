<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>useEffect vs useLayoutEffect</title><meta name="description" content="Ambos fazem basicamente a mesma coisa, mas eles têm aplicações levemente diferentes. Então, eis alguns pontos para levar em consideração ao decidir qual React Hook usar."/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/a4986f2a0e0938b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a4986f2a0e0938b8.css" data-n-g=""/><link rel="preload" href="/_next/static/css/27e945c305eddf9a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27e945c305eddf9a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-d98b4a7f39fdfc80.js" defer=""></script><script src="/_next/static/chunks/pages/_app-668718d66b7bab53.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bid%5D-a18d63f9f56431bc.js" defer=""></script><script src="/_next/static/Yix30HRKpOQ5MOfGP5eHx/_buildManifest.js" defer=""></script><script src="/_next/static/Yix30HRKpOQ5MOfGP5eHx/_ssgManifest.js" defer=""></script><script src="/_next/static/Yix30HRKpOQ5MOfGP5eHx/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><div class="Header_container__bLbkd"><div class="Header_grid__OFc_F"><a href="/"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path style="stroke:none;fill-rule:nonzero;fill:#000;fill-opacity:1" d="M11.113 0 13 1.887 6.773 8.004 13 14.114 11.113 16 3 8.004Zm0 0"></path></svg>Ver todos os posts</a></div></div><div class="Blog_article__ysQj0"><div class="Blog_articleContent__1fiLQ"><div class="Disclaimer_disclaimer__piAEp">A fim de democratizar o acesso a conteúdo técnico de desenvolvimento em português, este atigo é uma tradução de<!-- --> <a href="https://kentcdodds.com/blog/useeffect-vs-uselayouteffect" target="_blank" rel="noopener noreferrer">useEffect vs useLayoutEffect</a> <!-- -->por<!-- --> <a href="https://kentcdodds.com/" target="_blank" rel="noopener noreferrer">Kent C. Dodds</a>, traduzido por<!-- --> <a href="https://www.linkedin.com/in/vinicius-casarin-664315182/" target="_blank" rel="noopener noreferrer">Vinícius Casarin</a></div><article class="Blog_articleText__og2yo"><h1 id="useeffect-vs-uselayouteffect">useEffect vs useLayoutEffect</h1><p>Ambos fazem basicamente a mesma coisa, mas eles têm aplicações levemente diferentes.
Então, eis alguns pontos para levar em consideração ao decidir qual <em><a target="_blank" rel="noopener noreferrer" href="https://reactjs.org/hooks">React Hook</a></em> usar.</p><h2 id="useeffect"><a target="_blank" rel="noopener noreferrer" href="#useeffect">useEffect</a></h2><p>Esse é o que você vai usar a 99% das vezes. Ao refatorar um <em>class component</em> para utilizar <em>hooks</em>,
você provavelmente irá mover qualquer trecho de código de um <strong>componentDidMount</strong>, <strong>componentDidUpdate</strong>, e <strong>componentWillUnmount</strong> para um
<strong>useEffect</strong>.</p><p><strong>O ponto de atenção</strong> é que ele roda <em>depois</em> que o react renderiza seu componente
e garante que seu código não irá bloquear a renderização do browser. Isso se diferencia
do comportamento em <em>class components</em> onde <strong>componentDidMount</strong> e <strong>componentDidUpdate</strong>
rodam de forma síncrona após a renderização. Se fazendo mais performático e quase sempre é
o que você precisa.</p><p>No entanto, caso seu código vá alterar o DOM (via uma <a target="_blank" rel="noopener noreferrer" href="https://pt-br.reactjs.org/docs/refs-and-the-dom.html">Ref</a>)
<strong>e</strong> tal alteração for mudar a aparência do DOM entre o tempo que ele é renderizado e seu código executado,
<strong>você não deve</strong> usar o <strong>useEffect</strong>. Ou senão, é capaz que o usuário vejam uma tremidinha no seu layout,
esse é basicamente o único caso que você deve usar o <strong>useLayoutEffect</strong>.</p><h2 id="uselayouteffect"><a target="_blank" rel="noopener noreferrer" href="#uselayouteffect">useLayoutEffect</a></h2><p>Este roda de forma síncrona imediatamente após o React ter realizado todas as alterações no DOM.
Pode ser útil se você precisar calcular valores do DOM (como pegar a posição do scroll ou outros estilos de um elemento)
e alterar o DOM com base nelas, <strong>ou</strong> fazer um re-render síncrono atualizando o <em>state</em>.</p><p>Quanto ao ciclo de vida, ele funciona da mesma forma que <strong>componentDidMount</strong> e <strong>componentDidUpdate</strong>.
O código irá rodar assim que o DOM for atualizado, mas antes que o browser consiga mostrar na tela (o
usuário geralmente não nota uma atualização até que o browser mostre-a).</p><h2 id="resumo"><a target="_blank" rel="noopener noreferrer" href="#resumo">Resumo</a></h2><ul><li><strong>useLayoutEffect:</strong> Caso você <strong>precise</strong> alterar diretamente o DOM e/ou precise calcular algum valor dele.</li><li><strong>useEffect:</strong> Caso você não precise interagir com o DOM.</li></ul><h2 id="um-caso-fora-da-curva"><a target="_blank" rel="noopener noreferrer" href="#um-caso-fora-da-curva">Um caso fora da curva</a></h2><p>Uma outra situação em que você talvez precise utilizar o <strong>useLayoutEffect</strong>
é se você estiver utilizando um valor (como um <a target="_blank" rel="noopener noreferrer" href="https://pt-br.reactjs.org/docs/refs-and-the-dom.html">Ref</a>) e você
precisar ter certeza que seu valor esteja atualizado antes que qualquer coisa rode. Por exemplo:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
  ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token string">&quot;Um valor&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Então, em outro trecho do seu código</span>
<span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- Isso loga o valor antigo, pq roda antes!</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Nesse caso, a solução é usar o <strong>useLayoutEffect</strong>.</p><h2 id="conclusão"><a target="_blank" rel="noopener noreferrer" href="#conclusao">Conclusão</a></h2><p>O comportamento padrão é deixar que as atualizações do browser sejam ditadas pelo DOM
antes do seu código ser executado. Isso significa que seu código não irá bloquear o browser
e o usuário verá as alterações mais rápido. Então utilize o <code>useEffect</code> na maioria das vezes.</p></article><div class="Blog_tagsContainer__4rTXc"><span>Assuntos:</span><a href="/tag/frontend"><span class="TagList_tag__gWBqh">frontend</span></a><a href="/tag/react"><span class="TagList_tag__gWBqh">react</span></a><a href="/tag/javascript"><span class="TagList_tag__gWBqh">javascript</span></a><a href="/tag/react%20hooks"><span class="TagList_tag__gWBqh">react hooks</span></a></div></div></div><footer class="Footer_footer___dWe8"><a href="https://github.com/viniciuscasarin/blog-devptbr/blob/master/CONTRIBUA.md" target="_blank" rel="noopener noreferrer">Contribua!</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postMetadata":{"title":"useEffect vs useLayoutEffect","description":"Ambos fazem basicamente a mesma coisa, mas eles têm aplicações levemente diferentes. Então, eis alguns pontos para levar em consideração ao decidir qual React Hook usar.","date":"Jan 08, 2022","author":"Kent C. Dodds","authorUrl":"https://kentcdodds.com/","originalTitle":"useEffect vs useLayoutEffect","originalUrl":"https://kentcdodds.com/blog/useeffect-vs-uselayouteffect","translator":"Vinícius Casarin","translatorUrl":"https://www.linkedin.com/in/vinicius-casarin-664315182/","keywords":["frontend","react","javascript","react hooks"],"id":"useeffect-vs-uselayouteffect"},"postContent":{"compiledSource":"var d=Object.defineProperty,i=Object.defineProperties;var l=Object.getOwnPropertyDescriptors;var t=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable;var c=(a,o,n)=\u003eo in a?d(a,o,{enumerable:!0,configurable:!0,writable:!0,value:n}):a[o]=n,e=(a,o)=\u003e{for(var n in o||(o={}))r.call(o,n)\u0026\u0026c(a,n,o[n]);if(t)for(var n of t(o))p.call(o,n)\u0026\u0026c(a,n,o[n]);return a},m=(a,o)=\u003ei(a,l(o));var u=(a,o)=\u003e{var n={};for(var s in a)r.call(a,s)\u0026\u0026o.indexOf(s)\u003c0\u0026\u0026(n[s]=a[s]);if(a!=null\u0026\u0026t)for(var s of t(a))o.indexOf(s)\u003c0\u0026\u0026p.call(a,s)\u0026\u0026(n[s]=a[s]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var s=n,{components:a}=s,o=u(s,[\"components\"]);return mdx(MDXLayout,m(e(e({},layoutProps),o),{components:a,mdxType:\"MDXLayout\"}),mdx(\"h1\",e({},{id:\"useeffect-vs-uselayouteffect\"}),\"useEffect vs useLayoutEffect\"),mdx(\"p\",null,`Ambos fazem basicamente a mesma coisa, mas eles t\\xEAm aplica\\xE7\\xF5es levemente diferentes.\nEnt\\xE3o, eis alguns pontos para levar em considera\\xE7\\xE3o ao decidir qual `,mdx(\"em\",{parentName:\"p\"},mdx(\"a\",e({parentName:\"em\"},{href:\"https://reactjs.org/hooks\"}),\"React Hook\")),\" usar.\"),mdx(\"h2\",e({},{id:\"useeffect\"}),mdx(\"a\",e({parentName:\"h2\"},{href:\"#useeffect\"}),\"useEffect\")),mdx(\"p\",null,\"Esse \\xE9 o que voc\\xEA vai usar a 99% das vezes. Ao refatorar um \",mdx(\"em\",{parentName:\"p\"},\"class component\"),\" para utilizar \",mdx(\"em\",{parentName:\"p\"},\"hooks\"),`,\nvoc\\xEA provavelmente ir\\xE1 mover qualquer trecho de c\\xF3digo de um `,mdx(\"strong\",{parentName:\"p\"},\"componentDidMount\"),\", \",mdx(\"strong\",{parentName:\"p\"},\"componentDidUpdate\"),\", e \",mdx(\"strong\",{parentName:\"p\"},\"componentWillUnmount\"),` para um\n`,mdx(\"strong\",{parentName:\"p\"},\"useEffect\"),\".\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"O ponto de aten\\xE7\\xE3o\"),\" \\xE9 que ele roda \",mdx(\"em\",{parentName:\"p\"},\"depois\"),` que o react renderiza seu componente\ne garante que seu c\\xF3digo n\\xE3o ir\\xE1 bloquear a renderiza\\xE7\\xE3o do browser. Isso se diferencia\ndo comportamento em `,mdx(\"em\",{parentName:\"p\"},\"class components\"),\" onde \",mdx(\"strong\",{parentName:\"p\"},\"componentDidMount\"),\" e \",mdx(\"strong\",{parentName:\"p\"},\"componentDidUpdate\"),`\nrodam de forma s\\xEDncrona ap\\xF3s a renderiza\\xE7\\xE3o. Se fazendo mais perform\\xE1tico e quase sempre \\xE9\no que voc\\xEA precisa.`),mdx(\"p\",null,\"No entanto, caso seu c\\xF3digo v\\xE1 alterar o DOM (via uma \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://pt-br.reactjs.org/docs/refs-and-the-dom.html\"}),\"Ref\"),`)\n`,mdx(\"strong\",{parentName:\"p\"},\"e\"),` tal altera\\xE7\\xE3o for mudar a apar\\xEAncia do DOM entre o tempo que ele \\xE9 renderizado e seu c\\xF3digo executado,\n`,mdx(\"strong\",{parentName:\"p\"},\"voc\\xEA n\\xE3o deve\"),\" usar o \",mdx(\"strong\",{parentName:\"p\"},\"useEffect\"),`. Ou sen\\xE3o, \\xE9 capaz que o usu\\xE1rio vejam uma tremidinha no seu layout,\nesse \\xE9 basicamente o \\xFAnico caso que voc\\xEA deve usar o `,mdx(\"strong\",{parentName:\"p\"},\"useLayoutEffect\"),\".\"),mdx(\"h2\",e({},{id:\"uselayouteffect\"}),mdx(\"a\",e({parentName:\"h2\"},{href:\"#uselayouteffect\"}),\"useLayoutEffect\")),mdx(\"p\",null,`Este roda de forma s\\xEDncrona imediatamente ap\\xF3s o React ter realizado todas as altera\\xE7\\xF5es no DOM.\nPode ser \\xFAtil se voc\\xEA precisar calcular valores do DOM (como pegar a posi\\xE7\\xE3o do scroll ou outros estilos de um elemento)\ne alterar o DOM com base nelas, `,mdx(\"strong\",{parentName:\"p\"},\"ou\"),\" fazer um re-render s\\xEDncrono atualizando o \",mdx(\"em\",{parentName:\"p\"},\"state\"),\".\"),mdx(\"p\",null,\"Quanto ao ciclo de vida, ele funciona da mesma forma que \",mdx(\"strong\",{parentName:\"p\"},\"componentDidMount\"),\" e \",mdx(\"strong\",{parentName:\"p\"},\"componentDidUpdate\"),`.\nO c\\xF3digo ir\\xE1 rodar assim que o DOM for atualizado, mas antes que o browser consiga mostrar na tela (o\nusu\\xE1rio geralmente n\\xE3o nota uma atualiza\\xE7\\xE3o at\\xE9 que o browser mostre-a).`),mdx(\"h2\",e({},{id:\"resumo\"}),mdx(\"a\",e({parentName:\"h2\"},{href:\"#resumo\"}),\"Resumo\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"strong\",{parentName:\"li\"},\"useLayoutEffect:\"),\" Caso voc\\xEA \",mdx(\"strong\",{parentName:\"li\"},\"precise\"),\" alterar diretamente o DOM e/ou precise calcular algum valor dele.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"strong\",{parentName:\"li\"},\"useEffect:\"),\" Caso voc\\xEA n\\xE3o precise interagir com o DOM.\")),mdx(\"h2\",e({},{id:\"um-caso-fora-da-curva\"}),mdx(\"a\",e({parentName:\"h2\"},{href:\"#um-caso-fora-da-curva\"}),\"Um caso fora da curva\")),mdx(\"p\",null,\"Uma outra situa\\xE7\\xE3o em que voc\\xEA talvez precise utilizar o \",mdx(\"strong\",{parentName:\"p\"},\"useLayoutEffect\"),`\n\\xE9 se voc\\xEA estiver utilizando um valor (como um `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://pt-br.reactjs.org/docs/refs-and-the-dom.html\"}),\"Ref\"),`) e voc\\xEA\nprecisar ter certeza que seu valor esteja atualizado antes que qualquer coisa rode. Por exemplo:`),mdx(\"pre\",e({},{className:\"language-js\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" ref \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token maybe-class-name\"}),\"React\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token method function property-access\"}),\"useRef\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token maybe-class-name\"}),\"React\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token method function property-access\"}),\"useEffect\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token arrow operator\"}),\"=\u003e\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  ref`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token property-access\"}),\"current\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"Um valor\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"// Ent\\xE3o, em outro trecho do seu c\\xF3digo\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token maybe-class-name\"}),\"React\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token method function property-access\"}),\"useLayoutEffect\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token arrow operator\"}),\"=\u003e\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token console class-name\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token method function property-access\"}),\"log\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"ref\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token property-access\"}),\"current\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"// \u003c-- Isso loga o valor antigo, pq roda antes!\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`)),mdx(\"p\",null,\"Nesse caso, a solu\\xE7\\xE3o \\xE9 usar o \",mdx(\"strong\",{parentName:\"p\"},\"useLayoutEffect\"),\".\"),mdx(\"h2\",e({},{id:\"conclus\\xE3o\"}),mdx(\"a\",e({parentName:\"h2\"},{href:\"#conclusao\"}),\"Conclus\\xE3o\")),mdx(\"p\",null,`O comportamento padr\\xE3o \\xE9 deixar que as atualiza\\xE7\\xF5es do browser sejam ditadas pelo DOM\nantes do seu c\\xF3digo ser executado. Isso significa que seu c\\xF3digo n\\xE3o ir\\xE1 bloquear o browser\ne o usu\\xE1rio ver\\xE1 as altera\\xE7\\xF5es mais r\\xE1pido. Ent\\xE3o utilize o `,mdx(\"inlineCode\",{parentName:\"p\"},\"useEffect\"),\" na maioria das vezes.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"id":"useeffect-vs-uselayouteffect"},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"useeffect-vs-uselayouteffect"},"buildId":"Yix30HRKpOQ5MOfGP5eHx","runtimeConfig":{},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>